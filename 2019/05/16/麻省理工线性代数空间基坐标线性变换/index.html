<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>麻省理工线性代数空间基坐标线性变换 | 柏舟</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="关于吉尔伯特教授谈到的 A[输入向量坐标]=[输出空间坐标], 其中如何寻找矩阵A使这个式子成立，有这么一串公式：T(v_1)=a_1w_1+a_2w_2+...+a_nw_n 其中a1到$a_n$是矩阵A的第一列。如何理解呢？在之前的例子中，T(v)=Av中使用的是标准基，即所有标准基向量组合成的矩阵是单位矩阵（相当于每个基向量系数为1），标准基就是其中的每一列。 如$v_1 = \begin{">
<meta name="keywords" content="线性代数">
<meta property="og:type" content="article">
<meta property="og:title" content="麻省理工线性代数空间基坐标线性变换">
<meta property="og:url" content="https://landerku.github.io/2019/05/16/麻省理工线性代数空间基坐标线性变换/index.html">
<meta property="og:site_name" content="柏舟">
<meta property="og:description" content="关于吉尔伯特教授谈到的 A[输入向量坐标]=[输出空间坐标], 其中如何寻找矩阵A使这个式子成立，有这么一串公式：T(v_1)=a_1w_1+a_2w_2+...+a_nw_n 其中a1到$a_n$是矩阵A的第一列。如何理解呢？在之前的例子中，T(v)=Av中使用的是标准基，即所有标准基向量组合成的矩阵是单位矩阵（相当于每个基向量系数为1），标准基就是其中的每一列。 如$v_1 = \begin{">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-05-18T04:48:19.565Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="麻省理工线性代数空间基坐标线性变换">
<meta name="twitter:description" content="关于吉尔伯特教授谈到的 A[输入向量坐标]=[输出空间坐标], 其中如何寻找矩阵A使这个式子成立，有这么一串公式：T(v_1)=a_1w_1+a_2w_2+...+a_nw_n 其中a1到$a_n$是矩阵A的第一列。如何理解呢？在之前的例子中，T(v)=Av中使用的是标准基，即所有标准基向量组合成的矩阵是单位矩阵（相当于每个基向量系数为1），标准基就是其中的每一列。 如$v_1 = \begin{">
  
  <link rel="stylesheet" href="/Landerku.github.io/css/index.css">
</head>
</html>
<body style="


  background-color: #eff0f6

">
  <div id="container">
    <nav id="nav">
  <header class="header">
    <a href="/" class="title">柏舟</a>
  </header>
  <div class="ctnWrap">
    <div class="icons">
      
        
          
            <a href="http://www.liujiade.cn" target="_blank" class="nav-icn iconfont icon-个人主页"></a>
          
        
          
            <a href="https://github.com/Landerku" target="_blank" class="nav-icn iconfont icon-github"></a>
          
        
      
    </div>
    <div class="menu">
      
        
            <a href="/Landerku.github.io/" class="nav-menu ">主页</a>
          
        
            <a href="/Landerku.github.io/archives/" class="nav-menu ">归档</a>
          
        
            <a href="/Landerku.github.io/about/" class="nav-menu ">关于</a>
          
        
      
    </div>
  </div>
</nav>
    <div id="main"><section class="article">
  <h2 class="title">麻省理工线性代数空间基坐标线性变换</h2>
  <p class="sub">5月 16, 2019</p>
  <article class="content">
    <p>关于吉尔伯特教授谈到的 <strong>A[输入向量坐标]=[输出空间坐标]</strong>, 其中如何寻找矩阵A使这个式子成立，有这么一串公式：<script type="math/tex">T(v_1)=a_1w_1+a_2w_2+...+a_nw_n</script></p>
<p>其中a<sub>1</sub>到$a_n$是矩阵A的第一列。如何理解呢？在之前的例子中，T(v)=Av中使用的是标准基，即所有标准基向量组合成的矩阵是单位矩阵（相当于每个基向量系数为1），标准基就是其中的每一列。</p>
<p>如$v_1 = \begin{bmatrix}<br>1\\<br>0\\<br>\end{bmatrix} ，v_2 = \begin{bmatrix}<br>0\\<br>1\\<br>\end{bmatrix}或 T(v) = v_1+v_2+…+v_n.$</p>
<p>但一般而言，基向量并不都是标准基，所以在进行坐标变换的时候难免产生其他数字，也就是上述提到的$a_1$等。</p>
<center><strong>A的每一列就是输出空间坐标系的基向量进行线性组合的系数</strong></center>

<p>回到一般情况上，假设输入向量坐标${v = c_1v_1+c_2v_2+…+c_nv_n}$ 组成，其中$v_1，v_2到v_n$</p>
<p>是输入空间的<strong>基向量</strong>，$c_1，c_2$到$c_n$,是这些基向量组合的<strong>系数</strong>，也即向量v在这个坐标系中的<strong>坐标$(c_1,c_2,…c_n)$</strong>。</p>
<p>对向量v做线性变换到另一个坐标系中，其本质就是对原坐标进行变换，变换为一组输出空间基向量的组合系数，也即输出空间的坐标。什么意思呢，就是这个式子：<font color="#ff0000"><strong>（注意：我们对其做线性变换时只关注坐标即系数，不关心基向量）</strong></font></p>
<script type="math/tex; mode=display">A\begin{bmatrix}
{c_{1}}\\
{c_{2}}\\
{\vdots}\\
{c_{n}}\\
\end{bmatrix} = \begin{bmatrix}
{d_{1}}\\
{d_{2}}\\
{\vdots}\\
{d_{m}}\\
\end{bmatrix}</script><p>其中等式右边是V变换后W向量在输出空间的<strong>坐标（基向量系数）</strong>，如何理解呢？按照这个式子来思考： <script type="math/tex">T(v_1)=a_1w_1+a_2w_2+...+a_nw_n</script></p>
<p>其中只保留了<script type="math/tex">v_1</script>，相当于矩阵A右乘的系数中只保留了<script type="math/tex">v_1</script>的系数，即相当于，按<script type="math/tex">A*
\left[
 \begin{matrix}
   c_1 \\
   0  \\
   \vdots  \\
   0 
  \end{matrix} 
\right]</script><br>照$c_1$倍的A矩阵第一列加上0倍的其他列计算，$c_1$被A矩阵变换为，而这个<script type="math/tex">\left[
 \begin{matrix}
   c_1*a_{11} \\
   c_1*a_{21}  \\
   \vdots  \\
   c_1*a_{n1}
  \end{matrix} 
\right]</script></p>
<p>矩阵的每一行即是将<script type="math/tex">v_1</script>变换到新空间后<script type="math/tex">w_1,w_2到w_n</script>的系数，即将原空间的某个坐标变换成了输出空间一系列基向量的系数。</p>
<p>来看一道关于求导的例题。</p>
<p>输入：$c_1+c_2x+c_3x^2$          输入基向量： 1, x, x^2^</p>
<p>输出：$c_2+2c_3x$           输出基向量：1, x</p>
<p>转换矩阵<script type="math/tex">A = \begin{bmatrix}
{0}&{1}&{0}\\
{0}&{0}&{2}\\
\end{bmatrix}</script>来看 <script type="math/tex">A\begin{bmatrix}
{c_{1}}\\
{c_{2}}\\
{c_{3}}\\
\end{bmatrix} = \begin{bmatrix}
{c_{2}}\\
2{c_{3}}\\\end{bmatrix}</script> 可以分解为<script type="math/tex">\begin{bmatrix}
{0}*c_{1}&{1}*c_{2}&{0}*c_{3}\\
{0}c_{1}&{0}c_{2}&{2}c_{3}\\
\end{bmatrix}</script> </p>
<p>即将原坐标<script type="math/tex">c_1</script>转换成了0，坐标<script type="math/tex">c_2</script>转换成了<script type="math/tex">c_2</script>未变，<script type="math/tex">c_3</script>变为两倍。</p>
<p> 即T(1) = 0乘以基向量1 + 0*基向量x, <script type="math/tex">T(x) = c_2</script>乘以基向量1 + 0乘以基向量x，<script type="math/tex">T（x^2) = 0</script>乘以基向量<script type="math/tex">1 + 2c_3</script>乘以基向量x。</p>
<p>所以求导其实也是一种线性变换，从几何角度来说，相当于把n维的图像投影到了n-1维上，进行了降维操作。</p>

  </article>
  <footer class="f-cf">
    
      <a href="/Landerku.github.io/2019/05/18/测试/" class="link f-fl">⟵测试</a>
    
    
      <a href="/Landerku.github.io/2019/05/14/hello-world/" class="link f-fr">Hello World⟶</a>
    
  </footer>
</section></div>
    <footer id="footer" class="f-cf">
  <!-- 根据页面mathjax变量决定是否加载MathJax数学公式js -->

<!-- MathJax���ã���ͨ������Ԫ������д���ڹ�ʽ�� -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": { 
        preferredFont: "TeX", 
        availableFonts: ["STIX","TeX"], 
        linebreaks: { automatic:true }, 
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) 
    },
    tex2jax: { 
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ], 
        processEscapes: true, 
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {  
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, 
        Macros: { href: "{}" } 
    },
    messageStyle: "none"
    }); 
</script>
<!-- ��MathJaxԪ������has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- ͨ������CDN����MathJax��js���� -->
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

  1025liujia@gmail.com
  
    
      
        · <a href="http://www.liujiade.cn" target="_blank" class="nav-icn">个人主页</a>
      
    
      
        · <a href="https://github.com/Landerku" target="_blank" class="nav-icn">GitHub</a>
      
    
  
  <span class="copyright">版权所有 @Liu Jia</span>
</footer>
  </div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>