<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
 <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
 
  
  <title>麻省理工线代笔记：空间基坐标的线性代换 | 柏舟</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="注：1. 如加载出来的矩阵呈现错位，请在矩阵上右键——Math Settings——Math Render——Common Html即可。2. 如无法加载出公式及公式，请加载网页禁用脚本或选择查看全部内容。  关于吉尔伯特教授谈到的 A[输入向量坐标]=[输出空间坐标], 其中如何寻找矩阵A使这个式子成立，有这么一串公式：$T(v_1)=a_1w_1+a_2w_2+…+a_nw_n$ 其中a1到a">
<meta property="og:type" content="article">
<meta property="og:title" content="麻省理工线代笔记：空间基坐标的线性代换">
<meta property="og:url" content="https://landerku.github.io/2019/05/18/麻省理工线代笔记：空间基坐标的线性代换/index.html">
<meta property="og:site_name" content="柏舟">
<meta property="og:description" content="注：1. 如加载出来的矩阵呈现错位，请在矩阵上右键——Math Settings——Math Render——Common Html即可。2. 如无法加载出公式及公式，请加载网页禁用脚本或选择查看全部内容。  关于吉尔伯特教授谈到的 A[输入向量坐标]=[输出空间坐标], 其中如何寻找矩阵A使这个式子成立，有这么一串公式：$T(v_1)=a_1w_1+a_2w_2+…+a_nw_n$ 其中a1到a">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-05-19T09:05:24.595Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="麻省理工线代笔记：空间基坐标的线性代换">
<meta name="twitter:description" content="注：1. 如加载出来的矩阵呈现错位，请在矩阵上右键——Math Settings——Math Render——Common Html即可。2. 如无法加载出公式及公式，请加载网页禁用脚本或选择查看全部内容。  关于吉尔伯特教授谈到的 A[输入向量坐标]=[输出空间坐标], 其中如何寻找矩阵A使这个式子成立，有这么一串公式：$T(v_1)=a_1w_1+a_2w_2+…+a_nw_n$ 其中a1到a">
  
  <link rel="stylesheet" href="/Landerku.github.io/css/index.css">
</head>
</html>
<body style="


  background-color: #dae8f3

">
  <div id="container">
    <nav id="nav">
  <header class="header">
    <a href="/" class="title">柏舟</a>
  </header>
  <div class="ctnWrap">
    <div class="icons">
      
        
          
            <a href="http://www.liujiade.cn" target="_blank" class="nav-icn iconfont icon-个人主页"></a>
          
        
          
            <a href="https://github.com/Landerku" target="_blank" class="nav-icn iconfont icon-github"></a>
          
        
      
    </div>
    <div class="menu">
      
        
            <a href="/Landerku.github.io/" class="nav-menu ">HOME</a>
          
        
            <a href="/Landerku.github.io/archives" class="nav-menu ">ARCHIVES</a>
          
        
            <a href="/Landerku.github.io/about" class="nav-menu ">ABOUT</a>
          
        
      
    </div>
  </div>
</nav>
    <div id="main"><section class="article">
  <h2 class="title">麻省理工线代笔记：空间基坐标的线性代换</h2>
  <p class="sub">5月 18, 2019</p>
  <article class="content">
    <font color="red"><strong>注：1. 如加载出来的矩阵呈现错位，请在矩阵上右键——Math Settings——Math Render——Common Html即可。2. 如无法加载出公式及公式，请加载网页禁用脚本或选择查看全部内容。</strong></font>

<p>关于吉尔伯特教授谈到的 <strong>A[输入向量坐标]=[输出空间坐标]</strong>, 其中如何寻找矩阵A使这个式子成立，有这么一串公式：$T(v_1)=a_1w_1+a_2w_2+…+a_nw_n$</p>
<p>其中a1到an是矩阵A的第一列。如何理解呢？在之前的例子中，T(v)=Av中使用的是标准基，即所有标准基向量组合成的矩阵是单位矩阵（相当于每个基向量系数为1），标准基就是其中的每一列。</p>
<p>如v1 = <script type="math/tex">\begin{bmatrix}
1\\
0\\
\end{bmatrix}</script> ，v2 = <script type="math/tex">\begin{bmatrix}
0\\
1\\
\end{bmatrix}</script> ,或 $T(v) = v_1+v_2+…+v_n$但一般而言，基向量并不都是标准基，所以在进行坐标变换的时候难免产生其他数字，也就是上述提到的$a_1$等。</p>
<center><strong>A的每一列就是输出空间坐标系的基向量进行线性组合的系数</strong></center>

<p>回到一般情况上，假设输入向量坐标$v = c_1v_1+c_2v_2+…+c_nv_n$组成，其中$v_1，v_2$到$v_n$是输入空间的<strong>基向量</strong>，$c_1，c_2$到$c_n$是这些基向量组合的<strong>系数</strong>，也即向量v在这个坐标系中的<strong>坐标$(c_1,c_2,…c_n)$</strong>。</p>
<p>对向量v做线性变换到另一个坐标系中，其本质就是对原坐标进行变换，变换为一组输出空间基向量的组合系数，也即输出空间的坐标。什么意思呢，就是这个式子：<font color="#ff0000"><strong>（注意：我们对其做线性变换时只关注坐标即系数，不关心基向量）</strong></font></p>
<p>A<script type="math/tex">\begin{bmatrix}
{c_{1}}\\
{c_{2}}\\
{\vdots}\\
{c_{n}}\\
\end{bmatrix}</script> = <script type="math/tex">\begin{bmatrix}
{d_{1}}\\
{d_{2}}\\
{\vdots}\\
{d_{m}}\\
\end{bmatrix}</script> </p>
<p>其中等式右边是V变换后W向量在输出空间的<strong>坐标（基向量系数）</strong>，如何理解呢？按照这个式子来思考： <script type="math/tex">T(v_1)=a_1w_1+a_2w_2+...+a_nw_n</script>  其中只保留了$v_1$，相当于矩阵A右乘的系数中只保留了$v_1$的系数，<br>即相当于<br>$ A \begin{bmatrix}<br>{c_{1}}\<br>{0}\<br>{\vdots}\<br>{0}\<br>\end{bmatrix}$，按照$c_1$倍的A矩阵第一列加上0倍的其他列计算，$c_1$被A矩阵变换为$ \begin{bmatrix}<br>{c_{1}a_{11}}\<br>{c_{1}a_{21}}\<br>{\vdots}\<br>{c_{1}a\_{n1}}\<br>\end{bmatrix}$，而这个矩阵的每一行即是将$v\_1$变换到新空间后$w_1,w_2$到$w_n$的系数，即将原空间的某个坐标变换成了输出空间一系列基向量的系数。</p>
<p>来看一道关于求导的例题。</p>
<p>输入：$c_1+c_2x+c_3x^2$  输入基向量： $1, x, x^2$</p>
<p>输出：$c_2+2c_3x$  输出基向量：1, x</p>
<p>转换矩阵A = <script type="math/tex">\begin{bmatrix}
{0}&{1}&{0}\\
{0}&{0}&{2}\\
\end{bmatrix}</script></p>
<p>来看 A<script type="math/tex">\begin{bmatrix}
{c_{1}}\\
{c_{2}}\\
{c_{3}}\\
\end{bmatrix}</script> = <script type="math/tex">\begin{bmatrix}
{c_{2}}\\
2{c_{3}}\\
\end{bmatrix}</script> 可以分解为<script type="math/tex">\begin{bmatrix}
{0}c_{1}&{1}c_{2}&{0}c_{3}\\
{0}c_{1}&{0}c_{2}&{2}c_{3}\\
\end{bmatrix}</script> ，即将原坐标$c_1$转换成了0，坐标$c_2$转换成了$c_2$未变，$c_3$变为两倍。</p>
<p> 即$T(1) = 0$乘以基向量1 + 0*基向量x, $T(x) = c_2$乘以基向量1 + 0乘以基向量x，$T（x^2) = 0$乘以基向量$1 + 2c_3$乘以基向量x。</p>
<p>所以求导其实也是一种线性变换，从几何角度来说，相当于把n维的图像投影到了n-1维上，进行了降维操作。</p>

  </article>
  <footer class="f-cf">
    
      <a href="/Landerku.github.io/2019/05/19/子空间、向量空间维数和基向量维数一些补充/" class="link f-fl">⟵子空间、向量空间维数和基向量维数一些补充</a>
    
    
  </footer>
</section></div>
    <footer id="footer" class="f-cf">
  <!-- 根据页面mathjax变量决定是否加载MathJax数学公式js -->

<!-- MathJax���ã���ͨ������Ԫ������д���ڹ�ʽ�� -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "CommonHTML": { 
        preferredFont: "TeX", 
        availableFonts: ["STIX","TeX"], 
        linebreaks: { automatic:true }, 
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) 
    },
    tex2jax: { 
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ], 
        processEscapes: true, 
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {  
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, 
        Macros: { href: "{}" } 
    },
    messageStyle: "none"
    }); 
</script>
<!-- ��MathJaxԪ������has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- ͨ������CDN����MathJax��js���� -->
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

  1025liujia@gmail.com
  
    
      
        · <a href="http://www.liujiade.cn" target="_blank" class="nav-icn">个人主页</a>
      
    
      
        · <a href="https://github.com/Landerku" target="_blank" class="nav-icn">GitHub</a>
      
    
  
  <span class="copyright">版权所有 @Liu Jia</span>
</footer>
  </div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>