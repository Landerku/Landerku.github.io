<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>麻省理工线代笔记：空间基坐标的线性代换 | 柏舟</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="注：1. 如加载出来的矩阵呈现错位，请在矩阵上右键——Math Settings——Math Render——Common Html即可。2. 如无法加载出公式及公式，请加载网页禁用脚本或选择查看全部内容。  关于吉尔伯特教授谈到的 A[输入向量坐标]=[输出空间坐标], 其中如何寻找矩阵A使这个式子成立，有这么一串公式： T(v~1~)=a~1~w~1~+a~2~w~2~+…+a~n~w~n~">
<meta property="og:type" content="article">
<meta property="og:title" content="麻省理工线代笔记：空间基坐标的线性代换">
<meta property="og:url" content="https://landerku.github.io/2019/05/18/麻省理工线代笔记：空间基坐标的线性代换/index.html">
<meta property="og:site_name" content="柏舟">
<meta property="og:description" content="注：1. 如加载出来的矩阵呈现错位，请在矩阵上右键——Math Settings——Math Render——Common Html即可。2. 如无法加载出公式及公式，请加载网页禁用脚本或选择查看全部内容。  关于吉尔伯特教授谈到的 A[输入向量坐标]=[输出空间坐标], 其中如何寻找矩阵A使这个式子成立，有这么一串公式： T(v~1~)=a~1~w~1~+a~2~w~2~+…+a~n~w~n~">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-05-19T07:56:04.097Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="麻省理工线代笔记：空间基坐标的线性代换">
<meta name="twitter:description" content="注：1. 如加载出来的矩阵呈现错位，请在矩阵上右键——Math Settings——Math Render——Common Html即可。2. 如无法加载出公式及公式，请加载网页禁用脚本或选择查看全部内容。  关于吉尔伯特教授谈到的 A[输入向量坐标]=[输出空间坐标], 其中如何寻找矩阵A使这个式子成立，有这么一串公式： T(v~1~)=a~1~w~1~+a~2~w~2~+…+a~n~w~n~">
  
  <link rel="stylesheet" href="/Landerku.github.io/css/index.css">
</head>
</html>
<body style="


  background-color: #dae8f3

">
  <div id="container">
    <nav id="nav">
  <header class="header">
    <a href="/" class="title">柏舟</a>
  </header>
  <div class="ctnWrap">
    <div class="icons">
      
        
          
            <a href="http://www.liujiade.cn" target="_blank" class="nav-icn iconfont icon-个人主页"></a>
          
        
          
            <a href="https://github.com/Landerku" target="_blank" class="nav-icn iconfont icon-github"></a>
          
        
      
    </div>
    <div class="menu">
      
        
            <a href="/Landerku.github.io/" class="nav-menu ">主页</a>
          
        
            <a href="/Landerku.github.io/archives/" class="nav-menu ">归档</a>
          
        
            <a href="/Landerku.github.io/about/" class="nav-menu ">关于</a>
          
        
      
    </div>
  </div>
</nav>
    <div id="main"><section class="article">
  <h2 class="title">麻省理工线代笔记：空间基坐标的线性代换</h2>
  <p class="sub">5月 18, 2019</p>
  <article class="content">
    <font color="red"><strong>注：1. 如加载出来的矩阵呈现错位，请在矩阵上右键——Math Settings——Math Render——Common Html即可。2. 如无法加载出公式及公式，请加载网页禁用脚本或选择查看全部内容。</strong></font>

<p>关于吉尔伯特教授谈到的 <strong>A[输入向量坐标]=[输出空间坐标]</strong>, 其中如何寻找矩阵A使这个式子成立，有这么一串公式：</p>
<p>T(v~1~)=a~1~w~1~+a~2~w~2~+…+a~n~w~n~</p>
<p>其中a~1~到a~n~是矩阵A的第一列。如何理解呢？在之前的例子中，T(v)=Av中使用的是标准基，即所有标准基向量组合成的矩阵是单位矩阵（相当于每个基向量系数为1），标准基就是其中的每一列。</p>
<p>如v~1~ = <script type="math/tex">\begin{bmatrix}
1\\
0\\
\end{bmatrix}</script> ，v~2~ = <script type="math/tex">\begin{bmatrix}
0\\
1\\
\end{bmatrix}</script> ,或 T(v) = v~1~+v~2~+…+v~n~</p>
<p>但一般而言，基向量并不都是标准基，所以在进行坐标变换的时候难免产生其他数字，也就是上述提到的a~1~等。</p>
<center><strong>A的每一列就是输出空间坐标系的基向量进行线性组合的系数</strong></center>

<p>回到一般情况上，假设输入向量坐标v = c~1~v~1~+c~2~v~2~+…+c~n~v~n~组成，其中v~1~，v~2~到v~n~是输入空间的<strong>基向量</strong>，c~1~，c~2~到c~n~是这些基向量组合的<strong>系数</strong>，也即向量v在这个坐标系中的<strong>坐标(c~1~,c~2~,…c~n~)</strong>。</p>
<p>对向量v做线性变换到另一个坐标系中，其本质就是对原坐标进行变换，变换为一组输出空间基向量的组合系数，也即输出空间的坐标。什么意思呢，就是这个式子：<font color="#ff0000"><strong>（注意：我们对其做线性变换时只关注坐标即系数，不关心基向量）</strong></font></p>
<p>A<script type="math/tex">\begin{bmatrix}
{c_{1}}\\
{c_{2}}\\
{\vdots}\\
{c_{n}}\\
\end{bmatrix}</script> = <script type="math/tex">\begin{bmatrix}
{d_{1}}\\
{d_{2}}\\
{\vdots}\\
{d_{m}}\\
\end{bmatrix}</script> </p>
<p>其中等式右边是V变换后W向量在输出空间的<strong>坐标（基向量系数）</strong>，如何理解呢？按照这个式子来思考： T(v~1~)=a~1~w~1~+a~2~w~2~+…+a~n~w~n~ ，其中只保留了v~1~，相当于矩阵A右乘的系数中只保留了v~1~的系数，即相当于A<script type="math/tex">\begin{bmatrix}
{c_{1}}\\
{0}\\
{\vdots}\\
{0}\\
\end{bmatrix}</script>，按照c~1~倍的A矩阵第一列加上0倍的其他列计算，c~1~被A矩阵变换为<script type="math/tex">\begin{bmatrix}
{c_{1}a_{11}}\\
{c_{1}a_{21}}\\
{\vdots}\\
{c_{1}a_{n1}}\\
\end{bmatrix}</script>，而这个矩阵的每一行即是将v~1~变换到新空间后w~1~,w~2~到w~n~的系数，即将原空间的某个坐标变换成了输出空间一系列基向量的系数。</p>
<p>来看一道关于求导的例题。</p>
<p>输入：c~1~+c~2~x+c~3~x^2^  输入基向量： 1, x, x^2^</p>
<p>输出：c~2~+2c~3~x  输出基向量：1, x</p>
<p>转换矩阵A = <script type="math/tex">\begin{bmatrix}
{0}&{1}&{0}\\
{0}&{0}&{2}\\
\end{bmatrix}</script></p>
<p>来看 A<script type="math/tex">\begin{bmatrix}
{c_{1}}\\
{c_{2}}\\
{c_{3}}\\
\end{bmatrix}</script> = <script type="math/tex">\begin{bmatrix}
{c_{2}}\\
2{c_{3}}\\
\end{bmatrix}</script> 可以分解为<script type="math/tex">\begin{bmatrix}
{0}c_{1}&{1}c_{2}&{0}c_{3}\\
{0}c_{1}&{0}c_{2}&{2}c_{3}\\
\end{bmatrix}</script> ，即将原坐标c~1~转换成了0，坐标c~2~转换成了c~2~未变，c~3~变为两倍。</p>
<p> 即T(1) = 0乘以基向量1 + 0*基向量x, T(x) = c~2~乘以基向量1 + 0乘以基向量x，T（x^2^) = 0乘以基向量1 + 2c~3~乘以基向量x。</p>
<p>所以求导其实也是一种线性变换，从几何角度来说，相当于把n维的图像投影到了n-1维上，进行了降维操作。</p>

  </article>
  <footer class="f-cf">
    
      <a href="/Landerku.github.io/2019/05/19/子空间、向量空间维数和基向量维数一些补充/" class="link f-fl">⟵子空间、向量空间维数和基向量维数一些补充</a>
    
    
  </footer>
</section></div>
    <footer id="footer" class="f-cf">
  <!-- 根据页面mathjax变量决定是否加载MathJax数学公式js -->

<!-- MathJax���ã���ͨ������Ԫ������д���ڹ�ʽ�� -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": { 
        preferredFont: "TeX", 
        availableFonts: ["STIX","TeX"], 
        linebreaks: { automatic:true }, 
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) 
    },
    tex2jax: { 
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ], 
        processEscapes: true, 
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {  
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, 
        Macros: { href: "{}" } 
    },
    messageStyle: "none"
    }); 
</script>
<!-- ��MathJaxԪ������has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- ͨ������CDN����MathJax��js���� -->
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

  1025liujia@gmail.com
  
    
      
        · <a href="http://www.liujiade.cn" target="_blank" class="nav-icn">个人主页</a>
      
    
      
        · <a href="https://github.com/Landerku" target="_blank" class="nav-icn">GitHub</a>
      
    
  
  <span class="copyright">版权所有 @Liu Jia</span>
</footer>
  </div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>